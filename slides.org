#+Title: Creating a distributed python wrapper with otwrapy
#+Author: Felipe Aguirre Martinez
#+Email: aguirre@phimeca.com

#+OPTIONS: toc:nil reveal_mathjax:t reveal_slide_number:c/t reveal_progress:t reveal_history:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.
#+REVEAL_THEME: night
#+REVEAL_TRANS: none


* Introduction
- What is a wrapper ? it is a piece of code that creates a python interface that communicates with your code.
- A good wrapper can be parallelized
- Objective of this presentation --> Show you how to create the killer distributed wrapper to efficiently carry on uncertainty studies.
- It is based on the module [[http://felipeam86.github.io/otwrapy/][otwrapy]] available at [[https://github.com/felipeam86/otwrapy][GitHub]]. Proudly develloped at [[http://www.phimeca.com][Phimeca engineering]].
- A good working example can be found on the  [[https://github.com/felipeam86/otwrapy/tree/master/otwrapy/examples/beam][otwrapy repository]].

* What makes a good wrapper ?
- It catches and logs errors for easy debugging.
- It can either run or simply prepare runs --> usefull when running on clusters.
- It is distributed and avoids conflict between runs.
- You can use it as a script (argsparse module):
  #+BEGIN_SRC bash
  python wrapper.py –X 170 3 0.05
  #+END_SRC
- It is able to run on different environments:
  - Workstation
  - Office made heterogenous clusters --> e.g. IPyparallel or dispy
  - HPC through submission scripts --> e.g. TGCC or Poincare
  - Cloud solutions --> e.g. Simulagora or DominoUp

All of this  might seem complex, but wrappers are repetitive and [[http://felipeam86.github.io/otwrapy/][otwrapy]] is here for you !

* Basic skeleton of a wrapper

#+BEGIN_SRC python
class Wrapper(ot.OpenTURNSPythonFunction):
    """Wrapper of my external code.
    """

    def __init__(self, n, p):
        """Initialize the wrapper with n and p the input and output dimension.
        """
        super(Wrapper, self).__init__(n, p)

        """
        ...
        Do other stuff if necessary
        """
    def _exec(self, X):
        """Run the model in the shell for the input vector X
        """

        # Move to temp work dir. Cleanup at the end
        with otw.TempWorkDir(cleanup=True):
            # Create input file
            self._create_input_file(X)
            # Execute code
            runtime = self._call(X)
            # Retrieve output (see also ot.coupling_tools.get_value)
            Y = self._parse_output()

        return Y
#+END_SRC

** Temporary working directory

Efficiently and safely manage working on temporary directories with a context manager --> [[http://felipeam86.github.io/otwrapy/_generated/otwrapy.TempWorkDir.html#otwrapy-tempworkdir][otwrapy.TempWorkDir]]

#+BEGIN_SRC python
class TempWorkDir(object):
    """Implement a context manager that creates a temporary working directory.
    """
    def __init__(self, cleanup=False):
        self.dirname = mkdtemp(dir='/tmp')
        self.cleanup = cleanup
    def __enter__(self):
        self.curdir = os.getcwd()
        os.chdir(self.dirname)
    def __exit__(self, type, value, traceback):
        os.chdir(self.curdir)
        if self.cleanup:
            shutil.rmtree(self.dirname)


with TempWorkDir(cleanup=True):
    """
    ...
    Do stuff
    ...
    """
#+END_SRC

** Create input file
#+BEGIN_SRC python
    def _create_input_file(self, X):
        """Create the input file required by the code.
        """
        ot.coupling_tools.replace(
            'input_templatefile.xml',
            'input.xml',
            ['@X1','X2','@X3','@X4'],
            X)
#+END_SRC

** Execute code

#+BEGIN_SRC python
    def _call(self):
        """Execute code on the shell
        """

        time_start = time.time()
        ot.coupling_tools.execute('/path/to/executable -x input.xml')
        time_stop = time.time()

        return time_stop - time_start
#+END_SRC

** Parse output parameters

#+BEGIN_SRC python
    def _parse_output(self):
        """Parse the output given by the code
        """

        # Retrieve output (see also coupling_tools.get_value)
        xmldoc = minidom.parse('outputs.xml')
        itemlist = xmldoc.getElementsByTagName('outputs')
        Y = float(itemlist[0].attributes['Y1'].value)

        return [Y]
#+END_SRC

* Managing backups of input/output data

 [[http://felipeam86.github.io/otwrapy/_generated/otwrapy.dump_array.html][otwrapy.dump_array]] and  [[http://felipeam86.github.io/otwrapy/_generated/otwrapy.load_array.html][otwrapy.load_array]]

#+BEGIN_SRC python
def dump_array(array, filename, compress=False):
    """Dump an array to a (possibly compressed) file
    """
    if compress or (filename.split('.')[-1] == 'pklz'):
        with gzip.open(filename, 'wb') as fh:
            pickle.dump(array, fh, protocol=2)
    else:
        with open(filename, 'wb') as fh:
            pickle.dump(array, fh, protocol=2)

def load_array(filename, compressed=False):
    """Load a (possibly compressed) pickled array.
    """
    if compressed or (filename.split('.')[-1] == 'pklz'):
        with gzip.open(filename, 'rb') as fh:
            return pickle.load(fh)
    else:
        with open(filename, 'rb') as fh:
            return pickle.load(fh)
#+END_SRC

* Catch exceptions when your code fails

#+BEGIN_SRC python
class Wrapper(ot.OpenTURNSPythonFunction):
    def _exec(self, X):
        try:
            #Do stuff
        except Exception, e:
            logger.error(e, exc_info=True)
            raise e
        return Y
#+END_SRC

Even better, use [[http://felipeam86.github.io/otwrapy/_generated/otwrapy.Debug.html][otwrapy.Debug()]]

#+BEGIN_SRC python
class Wrapper(ot.OpenTURNSPythonFunction):
    @Debug('wrapper.log')
    def _exec(self, X):
        #Do stuff
        return Y
#+END_SRC
* Creating a CLI for your wrapper

#+BEGIN_SRC python
if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description="Python wrapper example.")
    parser.add_argument('-X', nargs=3, metavar=('X1', 'X2', 'X3'),
        help='Vector on which the model will be evaluated')
    args = parser.parse_args()

    model = Wrapper(3, 1)
    X = ot.NumericalPoint([float(x) for x in args.X])
    Y = model(X)
    dump_array(X, 'InputSample.pkl')
    dump_array(Y, 'OutputSample.pkl')
#+END_SRC

- You can then execute your code from the command line :

#+BEGIN_SRC bash
  python wrapper.py –X 170 3 0.05
#+END_SRC

* Parallelizing the wrapper
Just let the magic happend with [[http://felipeam86.github.io/otwrapy/_generated/otwrapy.Parallelizer.html][otwrapy.Parallelizer()]] !!

#+BEGIN_SRC python
parallelized_model = Parallelizer(Wrapper(*args, **kwards))
#+END_SRC

* Conclusion
-
-
-
-
-
-

* Thank you for your attention

[[http://www.phimeca.com][file:LogoPhiHautBlanc.png]]

Felipe Aguirre Martinez - aguirre@phimeca.com
